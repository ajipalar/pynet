from pyext.src.typedefs import KeyArray as KeyArray
from typing import Any

Dist: Any
EdgeID: Any
VertexID: Any
A: Any
G: Any
M: Any

def score(i, j, A): ...
def rsum(v): ...
def harmonic_restraint(d, mu, s: float = ...): ...
def degree_prior(degree, prior_degree, s: float = ...): ...
def priority_insert(obj, key, queue) -> None: ...
def priority_delete(key, queue) -> None: ...
def priority_remove_min(queue) -> None: ...
def priority_decrement(key, queue) -> None: ...
def adj(s, A): ...
def dijkstra(s, t, A): ...
def distance(s, t, A) -> Dist: ...
def dgrs(A): ...
def dgr(s, A): ...
def vmax(A): ...
def e_base(s, v): ...
def revert_sum(n): ...
def get_immutable_edge_id(s, t, vmax): ...
def get_edge_from_id(eid, vmax): ...
def src_from_eid(eid: EdgeID, v) -> VertexID: ...
def smart_mod(a, b): ...
def count(eid, v) -> None: ...
def get_immutable_vertices(eid, A) -> None: ...
def transition_kernal(A, n: int = ...) -> None: ...
def integral_lower_tri(x: int, v: int) -> int: ...
def edge_from_eid(eid, v): ...
def MH_MCMC(steps, target, seed, y, mustart, sigstart, mu_step_size: int = ..., sigma_step_size: int = ...): ...
def n_steps_mh(key: KeyArray, target_prob, target_params, mcmc_params): ...
def l_mh(key: KeyArray, target_lprob, params): ...
