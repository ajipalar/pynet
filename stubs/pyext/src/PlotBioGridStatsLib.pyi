from pathlib import Path
from pyext.src.jittools import is_jittable as is_jittable
from pyext.src.typedefs import Array as Array, ColName as ColName, DataFrame as DataFrame, DeviceArray as DeviceArray, Dimension as Dimension, GeneID as GeneID, Index as Index, Matrix as Matrix, PRNGKey as PRNGKey, ProteinName as ProteinName, Series as Series, State as State, Vector as Vector
from typing import Any, Callable

def minmaxlen(col): ...
def load_biogrid_v4_4(dpath) -> DataFrame: ...
def col_map(mapf: Callable, df: DataFrame, col: ColName) -> DataFrame: ...
def drop_columns(biogrid_df: DataFrame) -> DataFrame: ...
def filter_missing_entrez_interactors(d) -> DataFrame: ...
def get_frequency(col) -> dict[str, int]: ...
def get_physical(d): ...
def plot_physical_experiments(d) -> None: ...
def prepare_biogrid_fpipe(): ...
def prepare_biogrid(dpath): ...
def plot_col(d, colname, titlename: Any | None = ..., topn: int = ...): ...
def load_tip49_spec_counts_dataset() -> DataFrame: ...
def print_baitprey_info(spec_counts_df) -> None: ...
def check_if_tip49_proteins_in_biogrid(biogrid: DataFrame, spec: DataFrame): ...
def is_protein_name_in_biogrid(query_dict: dict[ProteinName, list[ColName]]): ...
def is_protein_name_not_in_biogrid(query_dict) -> list[ProteinName]: ...
def fraction_found(found: dict[ProteinName, bool]) -> tuple[float, int]: ...
def pipe_to_gvis(fpipe: list[Callable]): ...
def find_idmapping_overlap(biogrid, spec_counts_df) -> None: ...
def assert_valid_pure_functional_pipe(fpipe): ...
def filter_biogrid(tip49: DataFrame, biogrid: DataFrame): ...
def jbuild(f, **partial_kwargs) -> Callable: ...
def get_matrix_col_minus_s(s: Index, phi: Matrix, p: Dimension) -> Vector: ...
def get_random_phi_matrix(key: PRNGKey, p: Dimension) -> Matrix: ...
def get_random_X_matrix(key: PRNGKey, p: Dimension, n: Dimension, lam: float) -> Matrix: ...
def set_diag(phi: Matrix, diag: Vector) -> tuple[Matrix, Vector]: ...
def get_eta1(phi: Matrix, s: Index) -> float: ...
def get_eta2(theta: Vector, phi: Matrix, x_i: Vector, s: Index, p: Dimension) -> float: ...
def logsum(x): ...
def logfactorial(x_si): ...
def Zexp(eta1, eta2): ...
def get_exp_random_phi(key, p, unimin=..., unimax=...): ...
def Aexp(eta1, eta2): ...
def f0(xsi, eta1, eta2): ...
def fn(xsi, eta1): ...
def test_matrix_minus_slice(slicef) -> None: ...
def get_ncbi_gene_id(name, mg) -> GeneID: ...
def get_mmcif_structure(name: str, dpath: Path) -> object: ...
def get_saga_mmcif_structure() -> object: ...
def dev_surface_plot_block(): ...
def dev_numerical_approximation_block(): ...
def dev_ncbi_block(): ...
def dev_roc_examples_block(): ...
def dev_get_dev_state_poisson_sqr(): ...
def gibbs_sqr_init_params(key: PRNGKey, state: State) -> DeviceArray: ...
def gibbs_sqr_update_params(key: PRNGKey, state: State, params) -> DeviceArray: ...
def exponential_sqr_node_conditional(x: Vector, eta1: float, eta2: float, s: Index, Anode_Exp_natural) -> float: ...
def log_exponential_sqr_node_conditional(x: Vector, eta1: float, eta2: float, s: Index, Anode_Exp_natural) -> float: ...
def ll_exponential_sqr(x: Vector, eta1: float, eta2: float, p: Dimension, Anode_Exp_natural) -> float: ...
def ll_f_sqr_unormalized(x: Vector, eta1, eta2, f_0, p) -> float: ...
def gen_exponential(phi_exp: Matrix, p: Dimension, nsamples: Dimension): ...
def natural_sqr_likelihood(x: Vector, eta1: float, eta2: float, AexpNatural: Callable) -> float: ...
