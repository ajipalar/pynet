import abc
from abc import ABC, abstractmethod
from pyext.src.typedefs import Array as Array, DeviceArray as DeviceArray, Dimension as Dimension, GenericInvariants as GenericInvariants, Index as Index, JitFunc as JitFunc, Matrix as Matrix, Number as Number, PDF as PDF, PMF as PMF, PRNGKey as PRNGKey, PartialF as PartialF, Prob as Prob, PureFunc as PureFunc, RV as RV, Samples as Samples, Vector as Vector, Weights as Weights, fParam as fParam, iParam as iParam, lPDF as lPDF, lPMF as lPMF, lProb as lProb
from typing import Any, Callable

def specialize_model_to_sampling(model_getter: Callable, kwargs_params: dict, n_samples: int, n_inter: int) -> JitFunc: ...
def get_normal_model(mu: float, sigma: float, n_samples: int, n_inter: int) -> tuple[Callable, object, Callable, Callable]: ...

class ContractSample(ABC, metaclass=abc.ABCMeta):
    @abstractmethod
    def get_invariants(n_samples: Index, n_inter: Index) -> GenericInvariants: ...
    @abstractmethod
    def T(key: PRNGKey, x: DeviceArray, t: Index, n: Index, invariants: GenericInvariants) -> DeviceArray: ...
    @abstractmethod
    def get_log_intermediate_score(x: DeviceArray, n: Index, sample_state: dict) -> float: ...

class DerivedTypeViolation(ContractSample, metaclass=abc.ABCMeta):
    def get_invariants(x: float, y: float) -> float: ...

def sample(key: PRNGKey = ..., n_samples: Dimension = ..., n_inter: Dimension = ..., get_log_intermediate_score: JitFunc = ..., source: Any | None = ..., T: Callable = ..., get_invariants: Callable = ...) -> tuple[Samples, Weights]: ...
def get_mean__j(samples: Array = ..., weights: Array = ...) -> float: ...
def log_neal_interpolating_score_sequence__g(x: float = ..., beta: float = ..., log_source__j: lPDF = ..., log_target__j: lPDF = ...) -> float: ...
def nsteps_mh__g(key: PRNGKey = ..., x: float = ..., log_intermediate__j: lPDF = ..., intermediate_rv__j: Callable = ..., n_steps: int = ..., kwargs_log_intermediate__j: Any | None = ...) -> RV: ...
